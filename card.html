<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>–ö–∞—Ä—Ç–æ—á–∫–∏ –¥–ª—è –∏–∑—É—á–µ–Ω–∏—è —Å–ª–æ–≤</title>
    <style>
        :root {
            --safe-area-inset-top: env(safe-area-inset-top);
            --safe-area-inset-bottom: env(safe-area-inset-bottom);
            --safe-area-inset-left: env(safe-area-inset-left);
            --safe-area-inset-right: env(safe-area-inset-right);
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            user-select: none;
        }
        
        html, body {
            height: 100%;
            overflow-x: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
        }
        
        .app {
            max-width: 100%;
            min-height: 100vh;
            margin: 0 auto;
            background: white;
            border-radius: 0;
            box-shadow: none;
            display: flex;
            flex-direction: column;
        }
        
        @media (min-width: 768px) {
            .app {
                max-width: 1200px;
                border-radius: 15px;
                box-shadow: 0 10px 30px rgba(0,0,0,0.2);
                margin: 20px auto;
                min-height: auto;
            }
        }
        
        header {
            background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%);
            color: white;
            padding: 15px;
            text-align: center;
            padding-top: calc(15px + env(safe-area-inset-top));
        }
        
        .container {
            display: flex;
            flex: 1;
            flex-direction: column;
            min-height: 0;
        }
        
        @media (min-width: 768px) {
            .container {
                flex-direction: row;
            }
        }
        
        .sidebar {
            width: 100%;
            background: #f8fafc;
            padding: 12px;
            overflow-y: auto;
            border-bottom: 1px solid #e2e8f0;
        }
        
        @media (min-width: 768px) {
            .sidebar {
                width: 280px;
                border-right: 1px solid #e2e8f0;
                border-bottom: none;
            }
        }
        
        .main-content {
            flex: 1;
            padding: 15px;
            background: white;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }
        
        /* –£–º–µ–Ω—å—à–µ–Ω–Ω—ã–µ —Ç–∞–±—ã —Å —ç–º–æ–¥–∑–∏ */
        .tab-buttons {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 5px;
            margin-bottom: 15px;
            padding-bottom: 8px;
        }
        
        .tab-btn {
            padding: 10px 5px;
            border: none;
            background: #f1f5f9;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 500;
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 45px;
        }
        
        .tab-btn.active {
            background: #4f46e5;
            color: white;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        /* –ö–∞—Ä—Ç–æ—á–∫–∞ */
        .card {
            perspective: 1000px;
            width: 100%;
            height: 220px;
            margin: 15px auto;
        }
        
        @media (min-width: 768px) {
            .card {
                height: 400px;
                max-width: 450px;
            }
        }
        
        .card-inner {
            width: 100%;
            height: 100%;
            position: relative;
            transform-style: preserve-3d;
            transition: transform 0.6s;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }
        
        .card.flipped .card-inner {
            transform: rotateY(180deg);
        }
        
        .card-front, .card-back {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 22px;
            font-weight: 600;
            padding: 25px;
            text-align: center;
            border-radius: 12px;
            word-break: break-word;
        }
        
        @media (min-width: 768px) {
            .card-front, .card-back {
                font-size: 26px;
                padding: 35px;
            }
        }
        
        .card-front {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        
        .card-back {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            transform: rotateY(180deg);
        }
        
        /* –ö–Ω–æ–ø–∫–∏ —Å–º–∞—Ö–∏–≤–∞–Ω–∏—è - —Ç–æ–ª—å–∫–æ —ç–º–æ–¥–∑–∏ */
        .swipe-buttons {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 20px;
            padding-bottom: env(safe-area-inset-bottom);
        }
        
        .swipe-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 28px;
            cursor: pointer;
            user-select: none;
        }
        
        .swipe-left {
            background: #ef4444;
        }
        
        .swipe-right {
            background: #10b981;
        }
        
        /* –ú–æ–¥–∞–ª—å–Ω—ã–µ –æ–∫–Ω–∞ */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.7);
            align-items: center;
            justify-content: center;
            z-index: 1000;
            padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
        }
        
        .modal.active {
            display: flex;
        }
        
        .modal-content {
            background: white;
            padding: 18px;
            border-radius: 12px;
            width: 92%;
            max-width: 450px;
            max-height: 90vh;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            margin: auto;
            position: relative;
        }
        
        .close-modal {
            position: absolute;
            right: 15px;
            top: 15px;
            font-size: 22px;
            cursor: pointer;
            z-index: 1;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            background: #f1f5f9;
        }
        
        input, select, textarea {
            width: 100%;
            padding: 10px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-size: 15px;
            margin-top: 6px;
            -webkit-appearance: none;
        }
        
        textarea {
            min-height: 120px;
            resize: vertical;
        }
        
        button {
            background: #4f46e5;
            color: white;
            border: none;
            padding: 10px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 15px;
            font-weight: 500;
            transition: background 0.3s;
        }
        
        .btn-danger {
            background: #ef4444;
        }
        
        .btn-success {
            background: #10b981;
        }
        
        /* –ü—Ä–æ–≥—Ä–µ—Å—Å –±–∞—Ä –≤ –æ–¥–Ω—É —Å—Ç—Ä–æ–∫—É */
        .progress-info {
            background: #f8fafc;
            padding: 12px;
            border-radius: 10px;
            margin: 12px 0;
        }
        
        .progress-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            font-size: 14px;
        }
        
        .progress-bar {
            height: 6px;
            background: #e2e8f0;
            border-radius: 3px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #10b981, #059669);
            transition: width 0.3s;
        }
        
        /* –ö–æ–Ω—Ç—Ä–æ–ª—ã –∫–∞—Ä—Ç–æ—á–µ–∫ –≤ –æ–¥–Ω—É —Å—Ç—Ä–æ–∫—É —Å —ç–º–æ–¥–∑–∏ */
        .flashcard-controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            margin: 12px 0;
            flex-wrap: wrap;
        }
        
        .control-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 40px;
            height: 40px;
            border-radius: 8px;
            background: #f1f5f9;
            border: none;
            cursor: pointer;
            font-size: 18px;
        }
        
        .control-btn.active {
            background: #4f46e5;
            color: white;
        }
        
        /* –°–ø–∏—Å–æ–∫ –∫–æ–ª–æ–¥ —Å –∫–Ω–æ–ø–∫–∞–º–∏ –≤ –æ–¥–Ω—É —Å—Ç—Ä–æ–∫—É */
        .deck-list-item {
            display: flex;
            flex-direction: column;
            padding: 12px;
            margin: 8px 0;
            background: #f8fafc;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
            min-height: 70px;
        }
        
        .deck-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 8px;
        }
        
        .deck-title {
            font-weight: 600;
            font-size: 15px;
            flex: 1;
            margin-right: 10px;
        }
        
        .deck-actions-small {
            display: flex;
            gap: 4px;
        }
        
        .small-btn {
            width: 30px;
            height: 30px;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            padding: 0;
            background: #e2e8f0;
            color: #4f46e5;
            border: none;
        }
        
        .deck-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 4px;
        }
        
        .deck-info {
            font-size: 12px;
            color: #666;
        }
        
        .deck-main-actions {
            display: flex;
            gap: 6px;
        }
        
        .main-action-btn {
            padding: 6px 10px;
            font-size: 13px;
            border-radius: 6px;
        }
        
        /* –î–µ—Ä–µ–≤–æ –ø–∞–ø–æ–∫ —Å –º–∞–ª–µ–Ω—å–∫–∏–º–∏ –∫–Ω–æ–ø–∫–∞–º–∏ */
        .tree-view {
            list-style: none;
            padding-left: 10px;
        }
        
        .tree-item {
            padding: 10px;
            margin: 4px 0;
            background: white;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            min-height: 50px;
        }
        
        .tree-item-content {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
        }
        
        .tree-item-actions {
            display: flex;
            gap: 4px;
        }
        
        .tree-delete-btn {
            width: 28px;
            height: 28px;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            padding: 0;
            background: #fee2e2;
            color: #ef4444;
            border: none;
        }
        
        /* –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
            margin: 15px 0;
        }
        
        @media (min-width: 768px) {
            .stats-grid {
                grid-template-columns: repeat(4, 1fr);
                gap: 12px;
            }
        }
        
        .stat-card {
            background: #f8fafc;
            padding: 12px;
            border-radius: 8px;
            text-align: center;
            border: 1px solid #e2e8f0;
        }
        
        .stat-number {
            font-size: 22px;
            font-weight: bold;
            color: #4f46e5;
            margin: 3px 0;
        }
        
        /* –ú—É–ª—å—Ç–∏–∫–æ–ª–æ–¥–∞ */
        .multi-deck-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            margin: 6px 0;
            background: white;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
            cursor: pointer;
        }
        
        .multi-deck-item.selected {
            background: #f0f9ff;
            border-color: #4f46e5;
        }
        
        .multi-deck-item input[type="checkbox"] {
            width: 18px;
            height: 18px;
            margin: 0;
        }
        
        .iteration-selector-container {
            margin-bottom: 12px;
            padding: 12px;
            background: #f8fafc;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
        }
        
        .iteration-buttons {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            margin-top: 6px;
        }
        
        .iteration-btn {
            padding: 6px 10px;
            background: #e2e8f0;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
        }
        
        .iteration-btn.selected {
            background: #4f46e5;
            color: white;
        }
        
        /* –û–±—â–∏–µ —Å—Ç–∏–ª–∏ */
        h3 {
            font-size: 16px;
            margin-bottom: 10px;
        }
        
        h2 {
            font-size: 18px;
            margin-bottom: 10px;
        }
        
        .form-group {
            margin-bottom: 12px;
        }
    </style>
</head>
<body>
    <div class="app">
        <header>
            
            <div style="margin-top: 8px;">
                <button onclick="exportData()" style="padding: 6px 12px; font-size: 13px; margin-right: 8px;">üì§</button>
                <button onclick="importData()" style="padding: 6px 12px; font-size: 13px;">üì•</button>
            </div>
        </header>

        <div class="container">
            <div class="sidebar">
                <div class="tab-buttons">
                    <button class="tab-btn active" data-tab="folders">üìÅ</button>
                    <button class="tab-btn" data-tab="decks">üÉè</button>
                    <button class="tab-btn" data-tab="multi">üéØ</button>
                    <button class="tab-btn" data-tab="stats">üìä</button>
                </div>

                <div id="folders-tab" class="tab-content active">
                    <button onclick="showCreateFolderModal()" class="btn-success" style="width: 100%; padding: 8px; margin-bottom: 10px; font-size: 14px;">+ –ü–∞–ø–∫–∞</button>
                    <ul id="folders-tree" class="tree-view"></ul>
                </div>

                <div id="decks-tab" class="tab-content">
                    <button onclick="showCreateDeckModal()" class="btn-success" style="width: 100%; padding: 8px; margin-bottom: 10px; font-size: 14px;">+ –ö–æ–ª–æ–¥–∞</button>
                    <div id="decks-list"></div>
                </div>

                <div id="multi-tab" class="tab-content">
                    <h3>–í—ã–±–µ—Ä–∏—Ç–µ –∫–æ–ª–æ–¥—ã:</h3>
                    <div id="multi-decks-select" style="margin-bottom: 12px; max-height: 250px; overflow-y: auto;"></div>
                    <div class="form-group">
                        <label style="font-size: 14px;">–†–µ–∂–∏–º:</label>
                        <select id="multi-mode" style="font-size: 14px; padding: 8px;">
                            <option value="all">–í—Å–µ —Å–ª–æ–≤–∞</option>
                            <option value="unknown">–ù–µ–∏–∑—É—á–µ–Ω–Ω—ã–µ</option>
                            <option value="iteration">–ò–∑ –∏—Ç–µ—Ä–∞—Ü–∏–π</option>
                        </select>
                    </div>
                    <div id="iteration-selectors" style="display: none; margin-bottom: 12px;"></div>
                    <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                        <button onclick="startMultiDeck()" class="btn-success" style="flex: 1; padding: 8px; font-size: 14px;">‚ñ∂Ô∏è</button>
                        <button onclick="saveMultiDeckAsDeck()" id="save-multi-deck-btn" class="btn-success" style="flex: 1; padding: 8px; font-size: 14px; display: none;">üíæ</button>
                    </div>
                </div>

                <div id="stats-tab" class="tab-content">
                    <h3>–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞</h3>
                    <div class="stats-grid">
                        <div class="stat-card">
                            <div style="font-size: 0.75rem;">–°–ª–æ–≤</div>
                            <div class="stat-number" id="total-words">0</div>
                        </div>
                        <div class="stat-card">
                            <div style="font-size: 0.75rem;">–ò–∑—É—á–µ–Ω–æ</div>
                            <div class="stat-number" id="learned-words">0</div>
                        </div>
                        <div class="stat-card">
                            <div style="font-size: 0.75rem;">–ö–æ–ª–æ–¥</div>
                            <div class="stat-number" id="total-decks">0</div>
                        </div>
                        <div class="stat-card">
                            <div style="font-size: 0.75rem;">–ü–∞–ø–æ–∫</div>
                            <div class="stat-number" id="total-folders">0</div>
                        </div>
                    </div>
                    <div id="deck-stats" style="margin-top: 15px;"></div>
                </div>
            </div>

            <div class="main-content">
                <div id="main-content">
                    <h2>–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å!</h2>
                    <p style="margin-bottom: 15px; color: #666; font-size: 14px;">–°–æ–∑–¥–∞–π—Ç–µ –∫–æ–ª–æ–¥—É –∫–∞—Ä—Ç–æ—á–µ–∫ –∏–ª–∏ –≤—ã–±–µ—Ä–∏—Ç–µ —Å—É—â–µ—Å—Ç–≤—É—é—â—É—é.</p>
                    <div class="progress-info">
                        <h3 style="font-size: 15px; margin-bottom: 8px;">üìà –í–∞—à –ø—Ä–æ–≥—Ä–µ—Å—Å</h3>
                        <p style="font-size: 13px; color: #666;">–°–æ–∑–¥–∞–π—Ç–µ –∫–æ–ª–æ–¥—É, —á—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å –æ—Ç—Å–ª–µ–∂–∏–≤–∞—Ç—å –ø—Ä–æ–≥—Ä–µ—Å—Å</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- –ú–æ–¥–∞–ª—å–Ω—ã–µ –æ–∫–Ω–∞ -->
    <div id="create-folder-modal" class="modal">
        <div class="modal-content">
            <span class="close-modal" onclick="closeModal('create-folder-modal')">√ó</span>
            <h3>–°–æ–∑–¥–∞—Ç—å –ø–∞–ø–∫—É</h3>
            <input type="text" id="folder-name" placeholder="–ù–∞–∑–≤–∞–Ω–∏–µ –ø–∞–ø–∫–∏" style="margin-bottom: 12px;">
            <button onclick="createFolder()" class="btn-success">–°–æ–∑–¥–∞—Ç—å</button>
        </div>
    </div>

    <div id="create-deck-modal" class="modal">
        <div class="modal-content">
            <span class="close-modal" onclick="closeModal('create-deck-modal')">√ó</span>
            <h3>–°–æ–∑–¥–∞—Ç—å –∫–æ–ª–æ–¥—É</h3>
            <div class="form-group">
                <input type="text" id="deck-name" placeholder="–ù–∞–∑–≤–∞–Ω–∏–µ –∫–æ–ª–æ–¥—ã">
            </div>
            <div class="form-group">
                <textarea id="deck-words" placeholder="apple:—è–±–ª–æ–∫–æ
cat:–∫–æ—Ç
dog:—Å–æ–±–∞–∫–∞" rows="6"></textarea>
            </div>
            <div class="form-group">
                <label style="font-size: 14px;">–ü–∞–ø–∫–∞:</label>
                <select id="deck-folder">
                    <option value="">–ë–µ–∑ –ø–∞–ø–∫–∏</option>
                </select>
            </div>
            <button onclick="createDeck()" class="btn-success">–°–æ–∑–¥–∞—Ç—å</button>
        </div>
    </div>

    <div id="add-words-modal" class="modal">
        <div class="modal-content">
            <span class="close-modal" onclick="closeModal('add-words-modal')">√ó</span>
            <h3>–î–æ–±–∞–≤–∏—Ç—å —Å–ª–æ–≤–∞</h3>
            <textarea id="new-words" placeholder="apple:—è–±–ª–æ–∫–æ
cat:–∫–æ—Ç" rows="5" style="margin-bottom: 12px;"></textarea>
            <button onclick="addWordsToDeck()" class="btn-success">–î–æ–±–∞–≤–∏—Ç—å</button>
        </div>
    </div>

    <div id="study-modal" class="modal">
        <div class="modal-content">
            <span class="close-modal" onclick="closeStudyModal()">√ó</span>
            <h3 id="study-title" style="font-size: 16px; margin-bottom: 12px;">–ò–∑—É—á–µ–Ω–∏–µ</h3>
            
            <!-- –ö–æ–Ω—Ç—Ä–æ–ª—ã —Å —ç–º–æ–¥–∑–∏ –≤ –æ–¥–Ω—É —Å—Ç—Ä–æ–∫—É -->
            <div class="flashcard-controls">
                <button class="control-btn" id="shuffle-btn" onclick="toggleShuffle()" title="–ü–µ—Ä–µ–º–µ—à–∏–≤–∞—Ç—å">üîÄ</button>
                <button class="control-btn" id="reverse-btn" onclick="toggleReverse()" title="–û–±—Ä–∞—Ç–Ω–∞—è —Å—Ç–æ—Ä–æ–Ω–∞">üîÑ</button>
                <button class="control-btn" onclick="restartSession()" title="–ù–∞—á–∞—Ç—å –∑–∞–Ω–æ–≤–æ" style="background: #fee2e2; color: #ef4444;">üîÑ</button>
                <button class="control-btn" onclick="saveCurrentMultiDeck()" id="save-current-multi-deck-btn" title="–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –∫–∞–∫ –∫–æ–ª–æ–¥—É" style="display: none;">üíæ</button>
            </div>

            <!-- –ü—Ä–æ–≥—Ä–µ—Å—Å –≤ –æ–¥–Ω—É —Å—Ç—Ä–æ–∫—É -->
            <div class="progress-info">
                <div class="progress-header">
                    <div>üìä <span id="current-card">1</span>/<span id="total-cards">0</span></div>
                    <div>‚úÖ<span id="known-count">0</span> ‚ùå<span id="unknown-count">0</span></div>
                </div>
                <div class="progress-bar">
                    <div class="progress-fill" id="progress-fill" style="width: 0%"></div>
                </div>
            </div>

            <!-- –ö–∞—Ä—Ç–æ—á–∫–∞ -->
            <div class="card" id="flashcard" onclick="flipCard()">
                <div class="card-inner">
                    <div class="card-front" id="card-front">–ó–∞–≥—Ä—É–∑–∫–∞...</div>
                    <div class="card-back" id="card-back">–ó–∞–≥—Ä—É–∑–∫–∞...</div>
                </div>
            </div>

            <!-- –ö–Ω–æ–ø–∫–∏ —Å–º–∞—Ö–∏–≤–∞–Ω–∏—è - —Ç–æ–ª—å–∫–æ —ç–º–æ–¥–∑–∏ -->
            <div class="swipe-buttons">
                <div class="swipe-btn swipe-left" onclick="markUnknown()">
                    ‚ùå
                </div>
                <div class="swipe-btn swipe-right" onclick="markKnown()">
                    ‚úÖ
                </div>
            </div>
        </div>
    </div>

    <script>
        // –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
        let appData = {
            decks: [],
            folders: [],
            settings: {
                shuffle: false,
                reverse: false
            },
            studyProgress: {} // –•—Ä–∞–Ω–∏–º –ø—Ä–æ–≥—Ä–µ—Å—Å –∏–∑—É—á–µ–Ω–∏—è –¥–ª—è –∫–∞–∂–¥–æ–π –∫–æ–ª–æ–¥—ã
        };

        let currentStudySession = null;
        let currentDeckId = null;
        let currentMultiDeckConfig = null;
        let selectedIterations = {}; // –•—Ä–∞–Ω–∏–º –≤—ã–±—Ä–∞–Ω–Ω—ã–µ –∏—Ç–µ—Ä–∞—Ü–∏–∏ –¥–ª—è –º—É–ª—å—Ç–∏–∫–æ–ª–æ–¥—ã

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
        document.addEventListener('DOMContentLoaded', () => {
            loadData();
            initTabs();
            renderFoldersTree();
            renderDecksList();
            updateStats();
            initEventListeners();
        });

        // –ó–∞–≥—Ä—É–∑–∫–∞ –¥–∞–Ω–Ω—ã—Ö
        function loadData() {
            try {
                const saved = localStorage.getItem('flashcardAppData');
                if (saved) {
                    const parsed = JSON.parse(saved);
                    appData = parsed;
                    
                    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—â–∏—Ö –ø–æ–ª–µ–π
                    if (!appData.decks) appData.decks = [];
                    if (!appData.folders) appData.folders = [];
                    if (!appData.settings) appData.settings = { shuffle: false, reverse: false };
                    if (!appData.studyProgress) appData.studyProgress = {};
                    
                    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∫–æ–ª–æ–¥
                    appData.decks.forEach(deck => {
                        if (!deck.words) deck.words = [];
                        if (!deck.iterations) deck.iterations = [];
                        if (!deck.stats) deck.stats = { totalStudied: 0, lastStudied: null };
                        deck.words.forEach((word, index) => {
                            if (word.index === undefined) word.index = index;
                            if (!word.id) word.id = `word-${deck.id}-${index}`;
                        });
                    });
                }
            } catch (e) {
                console.error('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –¥–∞–Ω–Ω—ã—Ö:', e);
                appData = { 
                    decks: [], 
                    folders: [], 
                    settings: { shuffle: false, reverse: false },
                    studyProgress: {}
                };
            }
        }

        // –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö
        function saveData() {
            try {
                localStorage.setItem('flashcardAppData', JSON.stringify(appData));
            } catch (e) {
                console.error('–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö:', e);
                alert('–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö.');
            }
        }

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤ —Å–æ–±—ã—Ç–∏–π
        function initEventListeners() {
            // –†–µ–∂–∏–º –º—É–ª—å—Ç–∏–∫–æ–ª–æ–¥—ã
            const multiModeSelect = document.getElementById('multi-mode');
            if (multiModeSelect) {
                multiModeSelect.addEventListener('change', function() {
                    const iterationSelectors = document.getElementById('iteration-selectors');
                    iterationSelectors.style.display = this.value === 'iteration' ? 'block' : 'none';
                    document.getElementById('save-multi-deck-btn').style.display = 'none';
                    
                    if (this.value === 'iteration') {
                        renderIterationSelectors();
                    }
                });
            }
        }

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –≤–∫–ª–∞–¥–æ–∫
        function initTabs() {
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const tabId = btn.dataset.tab;
                    
                    document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    
                    document.querySelectorAll('.tab-content').forEach(content => {
                        content.classList.remove('active');
                    });
                    
                    const tabContent = document.getElementById(`${tabId}-tab`);
                    if (tabContent) tabContent.classList.add('active');
                    
                    if (tabId === 'multi') {
                        renderMultiDeckSelect();
                    }
                });
            });
        }

        // –ü–æ–∫–∞–∑/—Å–∫—Ä—ã—Ç–∏–µ –º–æ–¥–∞–ª—å–Ω—ã—Ö –æ–∫–æ–Ω
        function showModal(modalId) {
            document.getElementById(modalId).classList.add('active');
            document.body.style.overflow = 'hidden';
        }

        function closeModal(modalId) {
            document.getElementById(modalId).classList.remove('active');
            document.body.style.overflow = 'auto';
        }

        // –ü–∞—Ä—Å–∏–Ω–≥ —Å–ª–æ–≤ —Å –¥–≤–æ–µ—Ç–æ—á–∏–µ–º
        function parseWords(text) {
            const lines = text.split('\n');
            const words = [];
            
            lines.forEach((line, lineIndex) => {
                line = line.trim();
                if (!line) return;
                
                const colonIndex = line.indexOf(':');
                if (colonIndex === -1) return;
                
                const eng = line.substring(0, colonIndex).trim();
                const rus = line.substring(colonIndex + 1).trim();
                
                if (eng && rus) {
                    words.push({
                        eng: eng,
                        rus: rus,
                        index: words.length,
                        id: `word-${Date.now()}-${lineIndex}-${Math.random().toString(36).substr(2, 9)}`
                    });
                }
            });
            
            return words;
        }

        // –°–æ–∑–¥–∞–Ω–∏–µ –ø–∞–ø–∫–∏
        function showCreateFolderModal() {
            showModal('create-folder-modal');
        }

        function createFolder() {
            const name = document.getElementById('folder-name').value.trim();
            if (!name) {
                alert('–í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –ø–∞–ø–∫–∏');
                return;
            }
            
            const folder = {
                id: `folder-${Date.now()}`,
                name: name,
                decks: []
            };
            
            appData.folders.push(folder);
            saveData();
            closeModal('create-folder-modal');
            document.getElementById('folder-name').value = '';
            renderFoldersTree();
            updateStats();
        }

        // –°–æ–∑–¥–∞–Ω–∏–µ –∫–æ–ª–æ–¥—ã
        function showCreateDeckModal() {
            const folderSelect = document.getElementById('deck-folder');
            folderSelect.innerHTML = '<option value="">–ë–µ–∑ –ø–∞–ø–∫–∏</option>';
            
            appData.folders.forEach(folder => {
                folderSelect.innerHTML += `<option value="${folder.id}">${folder.name}</option>`;
            });
            
            showModal('create-deck-modal');
        }

        function createDeck() {
            const name = document.getElementById('deck-name').value.trim();
            const wordsText = document.getElementById('deck-words').value.trim();
            const folderId = document.getElementById('deck-folder').value;
            
            if (!name) {
                alert('–í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –∫–æ–ª–æ–¥—ã');
                return;
            }
            
            if (!wordsText) {
                alert('–í–≤–µ–¥–∏—Ç–µ —Å–ª–æ–≤–∞');
                return;
            }
            
            const words = parseWords(wordsText);
            if (words.length === 0) {
                alert('–ù–µ –Ω–∞–π–¥–µ–Ω–æ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã—Ö —Å–ª–æ–≤ –≤ —Ñ–æ—Ä–º–∞—Ç–µ "—Å–ª–æ–≤–æ:–ø–µ—Ä–µ–≤–æ–¥"');
                return;
            }
            
            const deck = {
                id: `deck-${Date.now()}`,
                name: name,
                words: words,
                folderId: folderId || null,
                createdAt: new Date().toISOString(),
                iterations: [],
                stats: {
                    totalStudied: 0,
                    lastStudied: null
                }
            };
            
            appData.decks.push(deck);
            
            if (folderId) {
                const folder = appData.folders.find(f => f.id === folderId);
                if (folder) {
                    folder.decks.push(deck.id);
                }
            }
            
            saveData();
            closeModal('create-deck-modal');
            
            document.getElementById('deck-name').value = '';
            document.getElementById('deck-words').value = '';
            
            renderFoldersTree();
            renderDecksList();
            updateStats();
            
            document.querySelector('[data-tab="decks"]').click();
        }

        // –†–µ–Ω–¥–µ—Ä –¥–µ—Ä–µ–≤–∞ –ø–∞–ø–æ–∫
        function renderFoldersTree() {
            const tree = document.getElementById('folders-tree');
            tree.innerHTML = '';
            
            // –ö–æ–ª–æ–¥—ã –±–µ–∑ –ø–∞–ø–æ–∫
            const rootDecks = appData.decks.filter(d => !d.folderId);
            if (rootDecks.length > 0) {
                rootDecks.forEach(deck => {
                    const item = document.createElement('div');
                    item.className = 'tree-item';
                    item.innerHTML = `
                        <div class="tree-item-content" onclick="studyDeck('${deck.id}')">
                            üÉè ${deck.name} <span style="font-size: 12px; color: #666;">(${deck.words.length})</span>
                        </div>
                        <div class="tree-item-actions">
                            <button class="small-btn" onclick="event.stopPropagation(); addWordsToDeckModal('${deck.id}')">+</button>
                            <button class="tree-delete-btn" onclick="event.stopPropagation(); deleteDeck('${deck.id}')">√ó</button>
                        </div>
                    `;
                    tree.appendChild(item);
                });
            }
            
            // –ü–∞–ø–∫–∏
            appData.folders.forEach(folder => {
                const folderDecks = appData.decks.filter(d => d.folderId === folder.id);
                
                const folderItem = document.createElement('div');
                folderItem.className = 'tree-item';
                folderItem.innerHTML = `
                    <div class="tree-item-content" onclick="toggleFolder('${folder.id}')">
                        üìÅ ${folder.name} <span style="font-size: 12px; color: #666;">(${folderDecks.length})</span>
                    </div>
                    <div class="tree-item-actions">
                        <button class="tree-delete-btn" onclick="event.stopPropagation(); deleteFolder('${folder.id}')">√ó</button>
                    </div>
                `;
                tree.appendChild(folderItem);
                
                const folderContent = document.createElement('div');
                folderContent.id = `folder-${folder.id}`;
                folderContent.style.paddingLeft = '20px';
                folderContent.style.display = 'block';
                
                folderDecks.forEach(deck => {
                    const deckItem = document.createElement('div');
                    deckItem.className = 'tree-item';
                    deckItem.style.margin = '4px 0';
                    deckItem.innerHTML = `
                        <div class="tree-item-content" onclick="studyDeck('${deck.id}')">
                            üÉè ${deck.name} <span style="font-size: 12px; color: #666;">(${deck.words.length})</span>
                        </div>
                        <div class="tree-item-actions">
                            <button class="small-btn" onclick="event.stopPropagation(); addWordsToDeckModal('${deck.id}')">+</button>
                            <button class="tree-delete-btn" onclick="event.stopPropagation(); deleteDeck('${deck.id}')">√ó</button>
                        </div>
                    `;
                    folderContent.appendChild(deckItem);
                });
                
                tree.appendChild(folderContent);
            });
        }

        function toggleFolder(folderId) {
            const content = document.getElementById(`folder-${folderId}`);
            if (content) {
                content.style.display = content.style.display === 'none' ? 'block' : 'none';
            }
        }

        // –†–µ–Ω–¥–µ—Ä —Å–ø–∏—Å–∫–∞ –∫–æ–ª–æ–¥
        function renderDecksList() {
            const list = document.getElementById('decks-list');
            list.innerHTML = '';
            
            if (appData.decks.length === 0) {
                list.innerHTML = '<p style="text-align: center; color: #666; padding: 20px; font-size: 14px;">–ù–µ—Ç —Å–æ–∑–¥–∞–Ω–Ω—ã—Ö –∫–æ–ª–æ–¥</p>';
                return;
            }
            
            appData.decks.forEach(deck => {
                const folder = deck.folderId ? appData.folders.find(f => f.id === deck.folderId) : null;
                const lastIteration = deck.iterations.length > 0 ? deck.iterations[deck.iterations.length - 1] : null;
                const knownCount = lastIteration ? lastIteration.knownWords.length : 0;
                
                const item = document.createElement('div');
                item.className = 'deck-list-item';
                item.innerHTML = `
                    <div class="deck-header">
                        <div class="deck-title">${deck.name}</div>
                        <div class="deck-actions-small">
                            <button class="small-btn" onclick="event.stopPropagation(); addWordsToDeckModal('${deck.id}')">+</button>
                            <button class="small-btn" onclick="event.stopPropagation(); deleteDeck('${deck.id}')" style="background: #fee2e2; color: #ef4444;">√ó</button>
                        </div>
                    </div>
                    <div class="deck-footer">
                        <div class="deck-info">
                            ${deck.words.length} —Å–ª–æ–≤
                            ${folder ? ` ‚Ä¢ ${folder.name}` : ''}
                            ${lastIteration ? ` ‚Ä¢ ‚úÖ${knownCount}` : ''}
                        </div>
                        <div class="deck-main-actions">
                            <button onclick="studyDeck('${deck.id}')" class="main-action-btn btn-success">‚ñ∂Ô∏è</button>
                        </div>
                    </div>
                `;
                list.appendChild(item);
            });
        }

        // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Å–ª–æ–≤ –≤ –∫–æ–ª–æ–¥—É
        function addWordsToDeckModal(deckId) {
            currentDeckId = deckId;
            showModal('add-words-modal');
        }

        function addWordsToDeck() {
            if (!currentDeckId) return;
            
            const deck = appData.decks.find(d => d.id === currentDeckId);
            if (!deck) return;
            
            const text = document.getElementById('new-words').value.trim();
            if (!text) {
                alert('–í–≤–µ–¥–∏—Ç–µ —Å–ª–æ–≤–∞');
                return;
            }
            
            const newWords = parseWords(text);
            const existingEngWords = new Set(deck.words.map(w => w.eng.toLowerCase()));
            
            let addedCount = 0;
            newWords.forEach(word => {
                if (!existingEngWords.has(word.eng.toLowerCase())) {
                    word.index = deck.words.length;
                    word.id = `word-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
                    deck.words.push(word);
                    existingEngWords.add(word.eng.toLowerCase());
                    addedCount++;
                }
            });
            
            if (addedCount > 0) {
                saveData();
                alert(`–î–æ–±–∞–≤–ª–µ–Ω–æ ${addedCount} –Ω–æ–≤—ã—Ö —Å–ª–æ–≤`);
            } else {
                alert('–í—Å–µ —Å–ª–æ–≤–∞ —É–∂–µ –µ—Å—Ç—å –≤ –∫–æ–ª–æ–¥–µ');
            }
            
            closeModal('add-words-modal');
            document.getElementById('new-words').value = '';
            renderFoldersTree();
            renderDecksList();
            updateStats();
        }

        // –£–¥–∞–ª–µ–Ω–∏–µ –∫–æ–ª–æ–¥—ã
        function deleteDeck(deckId) {
            if (!confirm('–£–¥–∞–ª–∏—Ç—å –∫–æ–ª–æ–¥—É?')) return;
            
            appData.decks = appData.decks.filter(d => d.id !== deckId);
            
            // –£–¥–∞–ª–∏—Ç—å –∏–∑ –ø–∞–ø–æ–∫
            appData.folders.forEach(folder => {
                folder.decks = folder.decks.filter(id => id !== deckId);
            });
            
            // –£–¥–∞–ª–∏—Ç—å –ø—Ä–æ–≥—Ä–µ—Å—Å
            if (appData.studyProgress[deckId]) {
                delete appData.studyProgress[deckId];
            }
            
            saveData();
            renderFoldersTree();
            renderDecksList();
            updateStats();
        }

        // –£–¥–∞–ª–µ–Ω–∏–µ –ø–∞–ø–∫–∏
        function deleteFolder(folderId) {
            const folder = appData.folders.find(f => f.id === folderId);
            if (!folder) return;
            
            if (folder.decks.length > 0) {
                if (!confirm('–í –ø–∞–ø–∫–µ –µ—Å—Ç—å –∫–æ–ª–æ–¥—ã. –£–¥–∞–ª–∏—Ç—å –ø–∞–ø–∫—É –∏ –≤—Å–µ –∫–æ–ª–æ–¥—ã –≤–Ω—É—Ç—Ä–∏?')) return;
                
                // –£–¥–∞–ª–∏—Ç—å –≤—Å–µ –∫–æ–ª–æ–¥—ã –≤ –ø–∞–ø–∫–µ
                appData.decks = appData.decks.filter(d => d.folderId !== folderId);
            }
            
            appData.folders = appData.folders.filter(f => f.id !== folderId);
            saveData();
            renderFoldersTree();
            updateStats();
        }

        // –ò–∑—É—á–µ–Ω–∏–µ –∫–æ–ª–æ–¥—ã - –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏–µ —Å —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω–æ–≥–æ –º–µ—Å—Ç–∞
        function studyDeck(deckId) {
            const deck = appData.decks.find(d => d.id === deckId);
            if (!deck || deck.words.length === 0) {
                alert('–ö–æ–ª–æ–¥–∞ –ø—É—Å—Ç–∞ –∏–ª–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞');
                return;
            }
            
            currentDeckId = deckId;
            
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–π –ø—Ä–æ–≥—Ä–µ—Å—Å
            const savedProgress = appData.studyProgress[deckId];
            let startIndex = 0;
            let knownWords = new Set();
            let unknownWords = new Set();
            let sessionWords = deck.words;
            
            if (savedProgress) {
                // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∏–∑ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω–æ–≥–æ –ø—Ä–æ–≥—Ä–µ—Å—Å–∞
                if (savedProgress.remainingWords && savedProgress.remainingWords.length > 0) {
                    // –°–æ–∑–¥–∞–µ–º —Å–µ—Å—Å–∏—é —Ç–æ–ª—å–∫–æ –∏–∑ –æ—Å—Ç–∞–≤—à–∏—Ö—Å—è —Å–ª–æ–≤
                    const wordsMap = new Map(deck.words.map(w => [w.id, w]));
                    const remainingWords = [];
                    
                    savedProgress.remainingWords.forEach(wordId => {
                        if (wordsMap.has(wordId)) {
                            remainingWords.push(wordsMap.get(wordId));
                        }
                    });
                    
                    if (remainingWords.length > 0) {
                        sessionWords = remainingWords;
                        startIndex = savedProgress.currentIndex || 0;
                        if (startIndex >= sessionWords.length) startIndex = 0;
                        knownWords = new Set(savedProgress.knownWords || []);
                        unknownWords = new Set(savedProgress.unknownWords || []);
                    }
                } else if (savedProgress.currentIndex !== undefined) {
                    // –°—Ç–∞—Ä—ã–π —Ñ–æ—Ä–º–∞—Ç –ø—Ä–æ–≥—Ä–µ—Å—Å–∞
                    startIndex = savedProgress.currentIndex;
                    if (startIndex >= deck.words.length) startIndex = 0;
                    knownWords = new Set(savedProgress.knownWords || []);
                    unknownWords = new Set(savedProgress.unknownWords || []);
                }
            }
            
            // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–µ—Å—Å–∏–∏
            currentStudySession = {
                deckId: deckId,
                currentIndex: startIndex,
                knownWords: knownWords,
                unknownWords: unknownWords,
                sessionWords: sessionWords,
                iterationNumber: deck.iterations.length + 1,
                isMultiDeck: false
            };
            
            // –û–±–Ω–æ–≤–ª—è–µ–º –∫–Ω–æ–ø–∫–∏ –Ω–∞—Å—Ç—Ä–æ–µ–∫
            document.getElementById('shuffle-btn').classList.toggle('active', appData.settings.shuffle);
            document.getElementById('reverse-btn').classList.toggle('active', appData.settings.reverse);
            
            // –°–∫—Ä—ã–≤–∞–µ–º –∫–Ω–æ–ø–∫—É —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –º—É–ª—å—Ç–∏–∫–æ–ª–æ–¥—ã
            document.getElementById('save-current-multi-deck-btn').style.display = 'none';
            
            if (appData.settings.shuffle) {
                shuffleWords();
            }
            
            document.getElementById('study-title').textContent = deck.name;
            showModal('study-modal');
            updateStudyUI();
        }

        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ UI –∏–∑—É—á–µ–Ω–∏—è
        function updateStudyUI() {
            if (!currentStudySession) return;
            
            const session = currentStudySession;
            const totalWords = session.sessionWords.length;
            
            if (totalWords === 0) {
                document.getElementById('card-front').textContent = 'üéâ –í—Å–µ —Å–ª–æ–≤–∞ –∏–∑—É—á–µ–Ω—ã!';
                document.getElementById('card-back').textContent = 'üéâ';
                document.getElementById('current-card').textContent = '0';
                document.getElementById('total-cards').textContent = '0';
                return;
            }
            
            const currentIndex = session.currentIndex;
            const currentWord = session.sessionWords[currentIndex];
            
            if (!currentWord) {
                console.error('–¢–µ–∫—É—â–µ–µ —Å–ª–æ–≤–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ');
                return;
            }
            
            const isReversed = appData.settings.reverse;
            
            document.getElementById('card-front').textContent = isReversed ? currentWord.rus : currentWord.eng;
            document.getElementById('card-back').textContent = isReversed ? currentWord.eng : currentWord.rus;
            
            document.getElementById('flashcard').classList.remove('flipped');
            
            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø—Ä–æ–≥—Ä–µ—Å—Å–∞
            document.getElementById('current-card').textContent = currentIndex + 1;
            document.getElementById('total-cards').textContent = totalWords;
            document.getElementById('known-count').textContent = session.knownWords.size;
            document.getElementById('unknown-count').textContent = session.unknownWords.size;
            
            const progress = ((currentIndex) / totalWords) * 100;
            document.getElementById('progress-fill').style.width = `${progress}%`;
        }

        // –ü–µ—Ä–µ–º–µ—à–∏–≤–∞–Ω–∏–µ
        function toggleShuffle() {
            const shuffleBtn = document.getElementById('shuffle-btn');
            appData.settings.shuffle = !appData.settings.shuffle;
            shuffleBtn.classList.toggle('active', appData.settings.shuffle);
            
            if (currentStudySession && appData.settings.shuffle) {
                shuffleWords();
                currentStudySession.currentIndex = 0;
                updateStudyUI();
            }
            
            saveData();
        }

        function shuffleWords() {
            if (!currentStudySession) return;
            
            const session = currentStudySession;
            const words = session.sessionWords;
            
            // –ü–µ—Ä–µ–º–µ—à–∏–≤–∞–µ–º —Ç–æ–ª—å–∫–æ –æ—Å—Ç–∞–≤—à–∏–µ—Å—è —Å–ª–æ–≤–∞
            const processedWords = words.slice(0, session.currentIndex);
            const remainingWords = words.slice(session.currentIndex);
            
            for (let i = remainingWords.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [remainingWords[i], remainingWords[j]] = [remainingWords[j], remainingWords[i]];
            }
            
            session.sessionWords = [...processedWords, ...remainingWords];
        }

        // –û–±—Ä–∞—Ç–Ω–∞—è —Å—Ç–æ—Ä–æ–Ω–∞
        function toggleReverse() {
            const reverseBtn = document.getElementById('reverse-btn');
            appData.settings.reverse = !appData.settings.reverse;
            reverseBtn.classList.toggle('active', appData.settings.reverse);
            saveData();
            updateStudyUI();
        }

        // –ü–µ—Ä–µ–≤–æ—Ä–æ—Ç –∫–∞—Ä—Ç–æ—á–∫–∏
        function flipCard() {
            document.getElementById('flashcard').classList.toggle('flipped');
        }

        // –û—Ç–º–µ—Ç–∏—Ç—å –∫–∞–∫ –∑–Ω–∞—é
        function markKnown() {
            if (!currentStudySession) return;
            
            const session = currentStudySession;
            const currentWord = session.sessionWords[session.currentIndex];
            
            if (currentWord) {
                session.knownWords.add(currentWord.id);
                session.unknownWords.delete(currentWord.id);
                
                // –°–æ—Ö—Ä–∞–Ω—è–µ–º –ø—Ä–æ–≥—Ä–µ—Å—Å
                saveStudyProgress();
            }
            
            nextCard();
        }

        // –û—Ç–º–µ—Ç–∏—Ç—å –∫–∞–∫ –Ω–µ –∑–Ω–∞—é
        function markUnknown() {
            if (!currentStudySession) return;
            
            const session = currentStudySession;
            const currentWord = session.sessionWords[session.currentIndex];
            
            if (currentWord) {
                session.unknownWords.add(currentWord.id);
                session.knownWords.delete(currentWord.id);
                
                // –°–æ—Ö—Ä–∞–Ω—è–µ–º –ø—Ä–æ–≥—Ä–µ—Å—Å
                saveStudyProgress();
            }
            
            nextCard();
        }

        // –°–ª–µ–¥—É—é—â–∞—è –∫–∞—Ä—Ç–æ—á–∫–∞
        function nextCard() {
            if (!currentStudySession) return;
            
            const session = currentStudySession;
            session.currentIndex++;
            
            if (session.currentIndex >= session.sessionWords.length) {
                finishStudySession();
            } else {
                updateStudyUI();
            }
        }

        // –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –ø—Ä–æ–≥—Ä–µ—Å—Å–∞ –∏–∑—É—á–µ–Ω–∏—è
        function saveStudyProgress() {
            if (!currentStudySession || !currentDeckId) return;
            
            const session = currentStudySession;
            
            // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ç–æ–ª—å–∫–æ –Ω–µ–∏–∑—É—á–µ–Ω–Ω—ã–µ —Å–ª–æ–≤–∞ –¥–ª—è –ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏—è
            const remainingWords = session.sessionWords
                .slice(session.currentIndex)
                .map(w => w.id);
            
            appData.studyProgress[currentDeckId] = {
                currentIndex: session.currentIndex,
                knownWords: Array.from(session.knownWords),
                unknownWords: Array.from(session.unknownWords),
                remainingWords: remainingWords,
                lastSaved: new Date().toISOString()
            };
            
            saveData();
        }

        // –ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ —Å–µ—Å—Å–∏–∏
        function finishStudySession() {
            if (!currentStudySession) return;
            
            const session = currentStudySession;
            
            // –ï—Å–ª–∏ —ç—Ç–æ –º—É–ª—å—Ç–∏–∫–æ–ª–æ–¥–∞
            if (session.isMultiDeck) {
                const unknownCount = session.unknownWords.size;
                
                if (unknownCount > 0) {
                    // –ü—Ä–æ–¥–æ–ª–∂–∞–µ–º —Ç–æ–ª—å–∫–æ —Å –Ω–µ–∏–∑—É—á–µ–Ω–Ω—ã–º–∏ —Å–ª–æ–≤–∞–º–∏
                    const unknownIds = new Set(session.unknownWords);
                    session.sessionWords = session.sessionWords.filter(
                        word => unknownIds.has(word.id)
                    );
                    session.currentIndex = 0;
                    session.knownWords.clear();
                    session.unknownWords.clear();
                    
                    // –°–æ—Ö—Ä–∞–Ω—è–µ–º –ø—Ä–æ–≥—Ä–µ—Å—Å –¥–ª—è –ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏—è
                    saveStudyProgress();
                    
                    updateStudyUI();
                } else {
                    // –í—Å–µ —Å–ª–æ–≤–∞ –∏–∑—É—á–µ–Ω—ã
                    alert('üéâ –í—Å–µ —Å–ª–æ–≤–∞ –∏–∑—É—á–µ–Ω—ã!');
                    closeStudyModal();
                }
            } else {
                // –î–ª—è –æ–±—ã—á–Ω–æ–π –∫–æ–ª–æ–¥—ã
                const deck = appData.decks.find(d => d.id === session.deckId);
                if (!deck) return;
                
                // –°–æ–∑–¥–∞–Ω–∏–µ –∏—Ç–µ—Ä–∞—Ü–∏–∏
                const iteration = {
                    number: session.iterationNumber,
                    date: new Date().toISOString(),
                    totalWords: deck.words.length,
                    knownWords: Array.from(session.knownWords),
                    unknownWords: Array.from(session.unknownWords)
                };
                
                deck.iterations.push(iteration);
                deck.stats.totalStudied++;
                deck.stats.lastStudied = new Date().toISOString();
                
                const unknownCount = session.unknownWords.size;
                
                if (unknownCount > 0) {
                    // –ü—Ä–æ–¥–æ–ª–∂–∞–µ–º —Å –Ω–µ–∏–∑—É—á–µ–Ω–Ω—ã–º–∏ —Å–ª–æ–≤–∞–º–∏
                    const unknownIds = new Set(session.unknownWords);
                    session.sessionWords = session.sessionWords.filter(
                        word => unknownIds.has(word.id)
                    );
                    session.currentIndex = 0;
                    session.knownWords.clear();
                    session.unknownWords.clear();
                    session.iterationNumber++;
                    
                    // –°–æ—Ö—Ä–∞–Ω—è–µ–º –ø—Ä–æ–≥—Ä–µ—Å—Å –¥–ª—è –ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏—è
                    saveStudyProgress();
                    
                    updateStudyUI();
                } else {
                    // –í—Å–µ —Å–ª–æ–≤–∞ –∏–∑—É—á–µ–Ω—ã - —É–¥–∞–ª—è–µ–º –ø—Ä–æ–≥—Ä–µ—Å—Å
                    delete appData.studyProgress[session.deckId];
                    saveData();
                    
                    alert('üéâ –í—Å–µ —Å–ª–æ–≤–∞ –∏–∑—É—á–µ–Ω—ã!');
                    closeStudyModal();
                }
            }
            
            updateStats();
        }

        // –ó–∞–∫—Ä—ã—Ç–∏–µ –æ–∫–Ω–∞ –∏–∑—É—á–µ–Ω–∏—è —Å —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ–º –ø—Ä–æ–≥—Ä–µ—Å—Å–∞
        function closeStudyModal() {
            if (currentStudySession && !currentStudySession.isMultiDeck) {
                // –°–æ—Ö—Ä–∞–Ω—è–µ–º –ø—Ä–æ–≥—Ä–µ—Å—Å –¥–ª—è –æ–±—ã—á–Ω—ã—Ö –∫–æ–ª–æ–¥
                saveStudyProgress();
            }
            
            currentStudySession = null;
            currentDeckId = null;
            currentMultiDeckConfig = null;
            
            closeModal('study-modal');
            updateStats();
        }

        // –ù–∞—á–∞—Ç—å –∑–∞–Ω–æ–≤–æ
        function restartSession() {
            if (!currentStudySession) return;
            
            const session = currentStudySession;
            
            if (session.isMultiDeck) {
                // –î–ª—è –º—É–ª—å—Ç–∏–∫–æ–ª–æ–¥—ã –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∂–∞–µ–º –∏–∑ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏
                if (currentMultiDeckConfig) {
                    createMultiDeckFromConfig(currentMultiDeckConfig);
                }
            } else {
                // –î–ª—è –æ–±—ã—á–Ω–æ–π –∫–æ–ª–æ–¥—ã
                const deck = appData.decks.find(d => d.id === session.deckId);
                if (!deck) return;
                
                // –£–¥–∞–ª—è–µ–º —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–π –ø—Ä–æ–≥—Ä–µ—Å—Å
                delete appData.studyProgress[session.deckId];
                saveData();
                
                session.currentIndex = 0;
                session.knownWords.clear();
                session.unknownWords.clear();
                session.sessionWords = [...deck.words];
                session.iterationNumber = deck.iterations.length + 1;
                
                if (appData.settings.shuffle) {
                    shuffleWords();
                }
            }
            
            updateStudyUI();
        }

        // –†–µ–Ω–¥–µ—Ä –≤—ã–±–æ—Ä–∞ –∫–æ–ª–æ–¥ –¥–ª—è –º—É–ª—å—Ç–∏–∫–æ–ª–æ–¥—ã
        function renderMultiDeckSelect() {
            const container = document.getElementById('multi-decks-select');
            container.innerHTML = '';
            
            if (appData.decks.length === 0) {
                container.innerHTML = '<p style="color: #666; text-align: center; padding: 15px; font-size: 14px;">–ù–µ—Ç —Å–æ–∑–¥–∞–Ω–Ω—ã—Ö –∫–æ–ª–æ–¥</p>';
                document.getElementById('save-multi-deck-btn').style.display = 'none';
                return;
            }
            
            appData.decks.forEach(deck => {
                const lastIter = deck.iterations.length > 0 ? deck.iterations[deck.iterations.length - 1] : null;
                const knownCount = lastIter ? lastIter.knownWords.length : 0;
                
                const deckItem = document.createElement('div');
                deckItem.className = 'multi-deck-item';
                deckItem.dataset.deckId = deck.id;
                deckItem.innerHTML = `
                    <input type="checkbox" id="multi-deck-${deck.id}" value="${deck.id}" 
                           class="multi-deck-checkbox">
                    <div style="flex: 1;">
                        <div style="font-weight: 500; margin-bottom: 2px; font-size: 14px;">${deck.name}</div>
                        <div style="font-size: 12px; color: #666;">
                            ${deck.words.length} —Å–ª–æ–≤, ‚úÖ${knownCount}
                        </div>
                    </div>
                `;
                
                deckItem.addEventListener('click', (e) => {
                    if (e.target.type !== 'checkbox') {
                        const checkbox = deckItem.querySelector('input[type="checkbox"]');
                        checkbox.checked = !checkbox.checked;
                        updateDeckItemSelection(deckItem, checkbox.checked);
                        
                        if (document.getElementById('multi-mode').value === 'iteration') {
                            renderIterationSelectors();
                        }
                    }
                });
                
                const checkbox = deckItem.querySelector('input[type="checkbox"]');
                checkbox.addEventListener('click', (e) => {
                    e.stopPropagation();
                    updateDeckItemSelection(deckItem, checkbox.checked);
                    
                    if (document.getElementById('multi-mode').value === 'iteration') {
                        renderIterationSelectors();
                    }
                });
                
                container.appendChild(deckItem);
            });
            
            document.getElementById('save-multi-deck-btn').style.display = 'none';
            updateAllDeckItemsSelection();
        }
        
        function updateDeckItemSelection(deckItem, isSelected) {
            if (isSelected) {
                deckItem.classList.add('selected');
            } else {
                deckItem.classList.remove('selected');
                delete selectedIterations[deckItem.dataset.deckId];
            }
        }
        
        function updateAllDeckItemsSelection() {
            document.querySelectorAll('.multi-deck-item').forEach(item => {
                const checkbox = item.querySelector('input[type="checkbox"]');
                updateDeckItemSelection(item, checkbox.checked);
            });
        }

        // –†–µ–Ω–¥–µ—Ä –≤—ã–±–æ—Ä–∞ –∏—Ç–µ—Ä–∞—Ü–∏–π —Å –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ–º —Å–ª–æ–≤
        function renderIterationSelectors() {
            const container = document.getElementById('iteration-selectors');
            container.innerHTML = '';
            selectedIterations = {};
            
            const selectedDeckIds = Array.from(
                document.querySelectorAll('.multi-deck-checkbox:checked')
            ).map(cb => cb.value);
            
            if (selectedDeckIds.length === 0) {
                container.innerHTML = '<p style="color: #666; text-align: center; font-size: 13px;">–í—ã–±–µ—Ä–∏—Ç–µ –∫–æ–ª–æ–¥—ã –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –∏—Ç–µ—Ä–∞—Ü–∏–π</p>';
                return;
            }
            
            let hasIterations = false;
            
            selectedDeckIds.forEach(deckId => {
                const deck = appData.decks.find(d => d.id === deckId);
                if (!deck || !deck.iterations || deck.iterations.length === 0) return;
                
                hasIterations = true;
                
                const selectorContainer = document.createElement('div');
                selectorContainer.className = 'iteration-selector-container';
                selectorContainer.innerHTML = `
                    <div style="font-weight: 500; margin-bottom: 6px; font-size: 14px;">${deck.name}:</div>
                    <div class="iteration-buttons" id="iterations-${deck.id}"></div>
                `;
                container.appendChild(selectorContainer);
                
                const buttonsContainer = document.getElementById(`iterations-${deck.id}`);
                
                deck.iterations.forEach(iter => {
                    const unknownCount = iter.unknownWords ? iter.unknownWords.length : 0;
                    const btn = document.createElement('button');
                    btn.type = 'button';
                    btn.className = 'iteration-btn';
                    btn.textContent = `${iter.number}(${unknownCount})`;
                    btn.dataset.deckId = deck.id;
                    btn.dataset.iterNum = iter.number;
                    
                    // –í—ã–±–∏—Ä–∞–µ–º –ø–æ—Å–ª–µ–¥–Ω—é—é –∏—Ç–µ—Ä–∞—Ü–∏—é –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
                    if (iter.number === deck.iterations.length) {
                        btn.classList.add('selected');
                        selectedIterations[deck.id] = iter.number;
                    }
                    
                    btn.addEventListener('click', () => {
                        document.querySelectorAll(`#iterations-${deck.id} .iteration-btn`).forEach(b => {
                            b.classList.remove('selected');
                        });
                        
                        btn.classList.add('selected');
                        selectedIterations[deck.id] = iter.number;
                    });
                    
                    buttonsContainer.appendChild(btn);
                });
            });
            
            if (!hasIterations) {
                container.innerHTML = '<p style="color: #666; text-align: center; font-size: 13px;">–£ –≤—ã–±—Ä–∞–Ω–Ω—ã—Ö –∫–æ–ª–æ–¥ –Ω–µ—Ç –∏—Ç–µ—Ä–∞—Ü–∏–π</p>';
            }
        }

        // –°–æ–∑–¥–∞–Ω–∏–µ –º—É–ª—å—Ç–∏–∫–æ–ª–æ–¥—ã –∏–∑ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏
        function createMultiDeckFromConfig(config) {
            let allWords = [];
            let totalWords = 0;
            
            config.deckIds.forEach(deckId => {
                const deck = appData.decks.find(d => d.id === deckId);
                if (!deck) return;
                
                let wordsToAdd = [];
                
                if (config.mode === 'all') {
                    wordsToAdd = deck.words.map(w => ({
                        ...w,
                        deckId: deck.id,
                        id: `multi-${w.id}-${Date.now()}`
                    }));
                } else if (config.mode === 'unknown') {
                    const lastIter = deck.iterations.length > 0 ? deck.iterations[deck.iterations.length - 1] : null;
                    if (lastIter && lastIter.unknownWords && lastIter.unknownWords.length > 0) {
                        const unknownIds = new Set(lastIter.unknownWords);
                        wordsToAdd = deck.words
                            .filter(w => unknownIds.has(w.id))
                            .map(w => ({
                                ...w,
                                deckId: deck.id,
                                id: `multi-${w.id}-${Date.now()}`
                            }));
                    } else {
                        wordsToAdd = deck.words.map(w => ({
                            ...w,
                            deckId: deck.id,
                            id: `multi-${w.id}-${Date.now()}`
                        }));
                    }
                } else if (config.mode === 'iteration') {
                    const selectedIterNum = selectedIterations[deckId];
                    if (selectedIterNum) {
                        const iteration = deck.iterations.find(iter => iter.number === selectedIterNum);
                        if (iteration && iteration.unknownWords) {
                            const unknownIds = new Set(iteration.unknownWords);
                            wordsToAdd = deck.words
                                .filter(w => unknownIds.has(w.id))
                                .map(w => ({
                                    ...w,
                                    deckId: deck.id,
                                    id: `multi-${w.id}-${Date.now()}`
                                }));
                        }
                    }
                }
                
                allWords = [...allWords, ...wordsToAdd];
                totalWords += wordsToAdd.length;
            });
            
            if (allWords.length === 0) {
                alert('–ù–µ—Ç —Å–ª–æ–≤ –¥–ª—è –∏–∑—É—á–µ–Ω–∏—è');
                return;
            }
            
            // –°–æ–∑–¥–∞–Ω–∏–µ –≤–∏—Ä—Ç—É–∞–ª—å–Ω–æ–π –∫–æ–ª–æ–¥—ã
            currentDeckId = `multi-${Date.now()}`;
            currentMultiDeckConfig = {
                deckIds: config.deckIds,
                mode: config.mode,
                totalWords: totalWords
            };
            
            currentStudySession = {
                deckId: currentDeckId,
                currentIndex: 0,
                knownWords: new Set(),
                unknownWords: new Set(),
                sessionWords: allWords,
                iterationNumber: 1,
                isMultiDeck: true
            };
            
            // –û–±–Ω–æ–≤–ª—è–µ–º –∫–Ω–æ–ø–∫–∏ –Ω–∞—Å—Ç—Ä–æ–µ–∫
            document.getElementById('shuffle-btn').classList.toggle('active', appData.settings.shuffle);
            document.getElementById('reverse-btn').classList.toggle('active', appData.settings.reverse);
            
            // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –∫–Ω–æ–ø–∫—É —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è
            document.getElementById('save-current-multi-deck-btn').style.display = 'flex';
            
            if (appData.settings.shuffle) {
                shuffleWords();
            }
            
            document.getElementById('study-title').textContent = `–ú—É–ª—å—Ç–∏–∫–æ–ª–æ–¥–∞ (${totalWords})`;
            showModal('study-modal');
            updateStudyUI();
        }

        // –ù–∞—á–∞—Ç—å –º—É–ª—å—Ç–∏–∫–æ–ª–æ–¥—É
        function startMultiDeck() {
            const selectedDecks = Array.from(
                document.querySelectorAll('.multi-deck-checkbox:checked')
            ).map(cb => cb.value);
            
            if (selectedDecks.length === 0) {
                alert('–í—ã–±–µ—Ä–∏—Ç–µ —Ö–æ—Ç—è –±—ã –æ–¥–Ω—É –∫–æ–ª–æ–¥—É');
                return;
            }
            
            const mode = document.getElementById('multi-mode').value;
            
            if (mode === 'iteration') {
                let missingIterations = [];
                
                selectedDecks.forEach(deckId => {
                    const deck = appData.decks.find(d => d.id === deckId);
                    if (!deck) return;
                    
                    if (!deck.iterations || deck.iterations.length === 0) {
                        missingIterations.push(`${deck.name} (–Ω–µ—Ç –∏—Ç–µ—Ä–∞—Ü–∏–π)`);
                    } else if (!selectedIterations[deckId]) {
                        selectedIterations[deckId] = deck.iterations.length;
                    }
                });
                
                if (missingIterations.length > 0) {
                    alert('–°–ª–µ–¥—É—é—â–∏–µ –∫–æ–ª–æ–¥—ã –Ω–µ –∏–º–µ—é—Ç –∏—Ç–µ—Ä–∞—Ü–∏–π:\n' + missingIterations.join('\n'));
                    return;
                }
            }
            
            const config = {
                deckIds: selectedDecks,
                mode: mode
            };
            
            createMultiDeckFromConfig(config);
        }

        // –°–æ—Ö—Ä–∞–Ω–∏—Ç—å —Ç–µ–∫—É—â—É—é –º—É–ª—å—Ç–∏–∫–æ–ª–æ–¥—É –∫–∞–∫ –∫–æ–ª–æ–¥—É
        function saveCurrentMultiDeck() {
            if (!currentStudySession || !currentStudySession.isMultiDeck) return;
            
            const name = prompt('–ù–∞–∑–≤–∞–Ω–∏–µ –∫–æ–ª–æ–¥—ã:', '–ú—É–ª—å—Ç–∏–∫–æ–ª–æ–¥–∞ ' + new Date().toLocaleDateString());
            if (!name) return;
            
            const uniqueWordsMap = new Map();
            currentStudySession.sessionWords.forEach(word => {
                const key = `${word.eng.toLowerCase()}:${word.rus.toLowerCase()}`;
                if (!uniqueWordsMap.has(key)) {
                    uniqueWordsMap.set(key, {
                        eng: word.eng,
                        rus: word.rus,
                        index: uniqueWordsMap.size
                    });
                }
            });
            
            const uniqueWords = Array.from(uniqueWordsMap.values());
            
            const newDeck = {
                id: `deck-${Date.now()}`,
                name: name,
                words: uniqueWords.map((w, index) => ({
                    ...w,
                    index: index,
                    id: `word-${Date.now()}-${index}`
                })),
                folderId: null,
                createdAt: new Date().toISOString(),
                iterations: [],
                stats: {
                    totalStudied: 0,
                    lastStudied: null
                }
            };
            
            appData.decks.push(newDeck);
            saveData();
            
            alert(`–ö–æ–ª–æ–¥–∞ "${name}" —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞! –°–ª–æ–≤: ${uniqueWords.length}`);
            
            renderFoldersTree();
            renderDecksList();
            updateStats();
            
            closeStudyModal();
        }

        // –°–æ—Ö—Ä–∞–Ω–∏—Ç—å –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é –º—É–ª—å—Ç–∏–∫–æ–ª–æ–¥—ã –∫–∞–∫ –∫–æ–ª–æ–¥—É
        function saveMultiDeckAsDeck() {
            const selectedDecks = Array.from(
                document.querySelectorAll('.multi-deck-checkbox:checked')
            ).map(cb => cb.value);
            
            if (selectedDecks.length === 0) {
                alert('–í—ã–±–µ—Ä–∏—Ç–µ —Ö–æ—Ç—è –±—ã –æ–¥–Ω—É –∫–æ–ª–æ–¥—É');
                return;
            }
            
            const mode = document.getElementById('multi-mode').value;
            
            let allWords = [];
            const uniqueWordsMap = new Map();
            
            selectedDecks.forEach(deckId => {
                const deck = appData.decks.find(d => d.id === deckId);
                if (!deck) return;
                
                let wordsToAdd = [];
                
                if (mode === 'all') {
                    wordsToAdd = deck.words.map(w => ({eng: w.eng, rus: w.rus}));
                } else if (mode === 'unknown') {
                    const lastIter = deck.iterations.length > 0 ? deck.iterations[deck.iterations.length - 1] : null;
                    if (lastIter && lastIter.unknownWords && lastIter.unknownWords.length > 0) {
                        const unknownIds = new Set(lastIter.unknownWords);
                        wordsToAdd = deck.words
                            .filter(w => unknownIds.has(w.id))
                            .map(w => ({eng: w.eng, rus: w.rus}));
                    } else {
                        wordsToAdd = deck.words.map(w => ({eng: w.eng, rus: w.rus}));
                    }
                } else if (mode === 'iteration') {
                    const selectedIterNum = selectedIterations[deckId];
                    if (selectedIterNum) {
                        const iteration = deck.iterations.find(iter => iter.number === selectedIterNum);
                        if (iteration && iteration.unknownWords) {
                            const unknownIds = new Set(iteration.unknownWords);
                            wordsToAdd = deck.words
                                .filter(w => unknownIds.has(w.id))
                                .map(w => ({eng: w.eng, rus: w.rus}));
                        } else {
                            wordsToAdd = deck.words.map(w => ({eng: w.eng, rus: w.rus}));
                        }
                    }
                }
                
                wordsToAdd.forEach(word => {
                    const key = `${word.eng.toLowerCase()}:${word.rus.toLowerCase()}`;
                    if (!uniqueWordsMap.has(key)) {
                        uniqueWordsMap.set(key, word);
                    }
                });
            });
            
            allWords = Array.from(uniqueWordsMap.values());
            
            if (allWords.length === 0) {
                alert('–ù–µ—Ç —Å–ª–æ–≤ –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è');
                return;
            }
            
            const name = prompt('–ù–∞–∑–≤–∞–Ω–∏–µ –∫–æ–ª–æ–¥—ã:', '–ú—É–ª—å—Ç–∏–∫–æ–ª–æ–¥–∞ ' + new Date().toLocaleDateString());
            if (!name) return;
            
            const newDeck = {
                id: `deck-${Date.now()}`,
                name: name,
                words: allWords.map((w, index) => ({
                    eng: w.eng,
                    rus: w.rus,
                    index: index,
                    id: `word-${Date.now()}-${index}`
                })),
                folderId: null,
                createdAt: new Date().toISOString(),
                iterations: [],
                stats: {
                    totalStudied: 0,
                    lastStudied: null
                }
            };
            
            appData.decks.push(newDeck);
            saveData();
            
            alert(`–ö–æ–ª–æ–¥–∞ "${name}" —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞! –°–ª–æ–≤: ${allWords.length}`);
            
            renderFoldersTree();
            renderDecksList();
            updateStats();
            
            document.getElementById('save-multi-deck-btn').style.display = 'none';
        }

        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
        function updateStats() {
            let totalWords = 0;
            let learnedWords = 0;
            let totalDecks = appData.decks.length;
            let totalFolders = appData.folders.length;
            
            appData.decks.forEach(deck => {
                totalWords += deck.words.length;
                
                if (deck.iterations.length > 0) {
                    const lastIter = deck.iterations[deck.iterations.length - 1];
                    learnedWords += lastIter.knownWords ? lastIter.knownWords.length : 0;
                }
            });
            
            document.getElementById('total-words').textContent = totalWords;
            document.getElementById('learned-words').textContent = learnedWords;
            document.getElementById('total-decks').textContent = totalDecks;
            document.getElementById('total-folders').textContent = totalFolders;
            
            const deckStats = document.getElementById('deck-stats');
            deckStats.innerHTML = '<h4 style="font-size: 15px; margin-bottom: 12px;">–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ –∫–æ–ª–æ–¥–∞–º:</h4>';
            
            if (appData.decks.length === 0) {
                deckStats.innerHTML = '<p style="color: #666; text-align: center; font-size: 14px;">–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö</p>';
                return;
            }
            
            appData.decks.forEach(deck => {
                const lastIter = deck.iterations.length > 0 ? deck.iterations[deck.iterations.length - 1] : null;
                const knownCount = lastIter && lastIter.knownWords ? lastIter.knownWords.length : 0;
                const progress = deck.words.length > 0 ? Math.round((knownCount / deck.words.length) * 100) : 0;
                
                const statEl = document.createElement('div');
                statEl.className = 'deck-list-item';
                statEl.innerHTML = `
                    <div class="deck-header">
                        <div class="deck-title">${deck.name}</div>
                    </div>
                    <div class="deck-footer">
                        <div class="deck-info">
                            ${deck.words.length} —Å–ª–æ–≤ | ${knownCount} (${progress}%) | ${deck.iterations.length} –∏—Ç.
                        </div>
                        <div class="deck-main-actions">
                            <button onclick="studyDeck('${deck.id}')" class="main-action-btn btn-success">‚ñ∂Ô∏è</button>
                        </div>
                    </div>
                `;
                deckStats.appendChild(statEl);
            });
        }

        // –≠–∫—Å–ø–æ—Ä—Ç –¥–∞–Ω–Ω—ã—Ö
        function exportData() {
            try {
                const dataStr = JSON.stringify(appData, null, 2);
                const dataUri = 'data:application/json;charset=utf-8,' + encodeURIComponent(dataStr);
                const exportFileName = 'flashcards-backup-' + new Date().toISOString().slice(0, 10) + '.json';
                
                const link = document.createElement('a');
                link.href = dataUri;
                link.download = exportFileName;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            } catch (e) {
                alert('–û—à–∏–±–∫–∞ —ç–∫—Å–ø–æ—Ä—Ç–∞ –¥–∞–Ω–Ω—ã—Ö');
            }
        }

        // –ò–º–ø–æ—Ä—Ç –¥–∞–Ω–Ω—ã—Ö
        function importData() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        if (!confirm('–ó–∞–º–µ–Ω–∏—Ç—å —Ç–µ–∫—É—â–∏–µ –¥–∞–Ω–Ω—ã–µ? –í—Å–µ –Ω–µ—Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è –±—É–¥—É—Ç –ø–æ—Ç–µ—Ä—è–Ω—ã.')) return;
                        
                        const importedData = JSON.parse(event.target.result);
                        appData = importedData;
                        saveData();
                        
                        renderFoldersTree();
                        renderDecksList();
                        updateStats();
                        alert('–î–∞–Ω–Ω—ã–µ —É—Å–ø–µ—à–Ω–æ –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω—ã!');
                    } catch (err) {
                        alert('–û—à–∏–±–∫–∞ –ø—Ä–∏ –∏–º–ø–æ—Ä—Ç–µ –¥–∞–Ω–Ω—ã—Ö. –§–∞–π–ª –ø–æ–≤—Ä–µ–∂–¥–µ–Ω –∏–ª–∏ –∏–º–µ–µ—Ç –Ω–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç.');
                    }
                };
                reader.readAsText(file);
            };
            
            input.click();
        }
    </script>
</body>
</html>
